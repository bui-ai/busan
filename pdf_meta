import os
import re
import fitz  # PyMuPDF
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from datetime import datetime
from langchain_ollama import ChatOllama
from langchain.schema import HumanMessage
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
import sys
import io

class RedirectText(io.StringIO):
    def __init__(self, text_widget):
        super().__init__()
        self.text_widget = text_widget
        self.text_widget.config(state=tk.NORMAL)

    def write(self, string):
        self.text_widget.insert(tk.END, string)
        self.text_widget.see(tk.END)
        self.text_widget.update_idletasks()
        
    def flush(self):
        pass

def extract_metadata_from_filename(filename):
    match = re.match(r"^(\d{6,8})[\- _]?(.*)\.pdf$", filename)  # 6~8ìë¦¬ ìˆ«ì ì¶”ì¶œ + êµ¬ë¶„ì ì²˜ë¦¬
    if not match:
        return None, None

    raw_date, title = match.groups()
    title = title.strip("-_ ")  # ì œëª©ì—ì„œ êµ¬ë¶„ì ì œê±°

    if len(raw_date) == 6:  # YYMMDD í˜•ì‹ (ì˜ˆ: 230501)
        year_base = int(raw_date[:2])

        # 80 ì´ìƒì´ë©´ 1900ë…„ëŒ€, ê·¸ ì´í•˜ë©´ 2000ë…„ëŒ€
        if year_base >= 80:
            year = f"19{year_base}"
        else:
            year = f"20{year_base}"

        month = raw_date[2:4]
        day = raw_date[4:]
    elif len(raw_date) == 8:
        year = raw_date[:4]
        month = raw_date[4:6]
        day = raw_date[6:]
    else:
        return None, title
    
    formatted_date = f"{year}-{month}-{day}"
    return formatted_date, title

def extract_text_from_pdf(pdf_path):
    doc = fitz.open(pdf_path)
    text = "\n".join([page.get_text("text") for page in doc])
    return text

def cluster_and_select_key_sentences(text, num_clusters=5):
    # 1. ë¬¸ì¥ì„ ë¬¸ì¥ ë‹¨ìœ„ë¡œ ë¶„í• 
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=200, chunk_overlap=20)
    sentences = text_splitter.split_text(text)

    # 2. ì„ë² ë”© ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ì¥ ì„ë² ë”© ìƒì„±
    embedding_model = HuggingFaceEmbeddings(model_name="snunlp/KR-SBERT-V40K-klueNLI-augSTS")
    sentence_vectors = np.array([embedding_model.embed_query(sentence) for sentence in sentences])

    # 3. K-Means í´ëŸ¬ìŠ¤í„°ë§ ì ìš©
    kmeans = KMeans(n_clusters=num_clusters, random_state=42, n_init=10)
    kmeans.fit(sentence_vectors)
    cluster_centers = kmeans.cluster_centers_

    # 4. ê° í´ëŸ¬ìŠ¤í„°ì—ì„œ ì¤‘ì‹¬ì— ê°€ê¹Œìš´ ë¬¸ì¥ ì„ íƒ
    selected_sentences = []
    for center in cluster_centers:
        distances = np.linalg.norm(sentence_vectors - center, axis=1)
        closest_sentence_idx = np.argmin(distances)
        selected_sentences.append(sentences[closest_sentence_idx])

    return "\n".join(selected_sentences)  # ëŒ€í‘œ ë¬¸ì¥ë“¤ì„ ë°˜í™˜

def generate_summary_and_keywords(text):
    try:
        llm = ChatOllama(model="EXAONE-3.5-7.8B-Instruct", temperature=0.3)

        # âœ… í´ëŸ¬ìŠ¤í„°ë§ì„ í†µí•´ ëŒ€í‘œ ë¬¸ì¥ ì„ íƒ
        key_sentences = cluster_and_select_key_sentences(text, num_clusters=5)

        prompt = f"""
        ë¬¸ì„œë¥¼ ì½ê³  ë‹¤ìŒ ì •ë³´ë¥¼ ìƒì„±í•˜ì„¸ìš”:
        1. ìš”ì•½ (200ì ì´ë‚´, í•µì‹¬ ë‚´ìš©ì„ ê°„ê²°í•˜ê²Œ ì„œìˆ )
        2. ì£¼ìš” í‚¤ì›Œë“œ (10ê°œ ì´ë‚´, ë‹¨ì–´ë§Œ ì œê³µ, ì‰¼í‘œë¡œ êµ¬ë¶„)

        ë¬¸ì„œ ë‚´ìš©:
        {key_sentences}
        """
        
        response = llm.invoke([HumanMessage(content=prompt)])
        output_text = response.content.strip()

        # ìš”ì•½ê³¼ í‚¤ì›Œë“œ ì •ê·œì‹ ì¶”ì¶œ
        summary_match = re.search(r"(?<=ìš”ì•½:).*", output_text)
        keywords_match = re.search(r"(?<=í‚¤ì›Œë“œ:).*", output_text)

        summary = summary_match.group(0).strip() if summary_match else "ìš”ì•½ ì—†ìŒ"
        keywords = keywords_match.group(0).strip() if keywords_match else "í‚¤ì›Œë“œ ì—†ìŒ"

        # í‚¤ì›Œë“œ ì‰¼í‘œ ë³€í™˜
        if " " in keywords and "," not in keywords:
            keywords = ", ".join(keywords.split())

        return summary, keywords

    except Exception as e:
        return f"LLM ì˜¤ë¥˜ ë°œìƒ: {str(e)}", "í‚¤ì›Œë“œ ì—†ìŒ"

def update_pdf_metadata(pdf_path, title, subject, keywords, creation_date, output_folder):
    doc = fitz.open(pdf_path)
    
    if doc.is_encrypted:
        try:
            doc.authenticate("")  # ì•”í˜¸ ì—†ëŠ” ê²½ìš° í•´ì œ ì‹œë„
        except Exception:
            print(f"âš ï¸ ì•”í˜¸í™”ëœ PDF: {pdf_path}, ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸ ë¶ˆê°€")
            return
    
    metadata = doc.metadata
    metadata["title"] = title  # Titleì€ ë¬¸ì„œ ì œëª©
    metadata["subject"] = subject  # SubjectëŠ” ìš”ì•½ ë‚´ìš©
    metadata["keywords"] = keywords
    metadata["creationDate"] = datetime.strptime(creation_date, "%Y-%m-%d").isoformat()
    
    output_path = os.path.join(output_folder, os.path.basename(pdf_path))
    temp_path = output_path + "_temp.pdf"
    
    new_doc = fitz.open()
    for page in doc:
        new_doc.insert_pdf(doc, from_page=page.number, to_page=page.number)
    
    new_doc.set_metadata(metadata)
    new_doc.save(temp_path, garbage=4, deflate=True, incremental=False)
    new_doc.close()
    doc.close()
    os.replace(temp_path, output_path)

def process_pdf(pdf_path, metadata_list, output_folder):
    filename = os.path.basename(pdf_path)
    creation_date, title = extract_metadata_from_filename(filename)
    if not creation_date:
        print(f"âš ï¸ íŒŒì¼ëª…ì—ì„œ ë©”íƒ€ë°ì´í„°ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŒ: {filename}")
        return
    
    text = extract_text_from_pdf(pdf_path)
    summary, keywords = generate_summary_and_keywords(text)
    
    update_pdf_metadata(pdf_path, title, summary, keywords, creation_date, output_folder)
    print(f"âœ… {filename} ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸ ì™„ë£Œ!")
    
    metadata_list.append({
        "Filename": filename,
        "Title": title,  # Titleì€ íŒŒì¼ëª…ì—ì„œ ê°€ì ¸ì˜¨ ë¬¸ì„œ ì œëª©
        "Subject": summary,  # SubjectëŠ” ìš”ì•½ ë‚´ìš©
        "Keywords": keywords,
        "Creation Date": creation_date
    })

def process_pdf_folder(input_folder, output_folder):
    metadata_list = []
    output_csv = os.path.join(output_folder, "pdf_metadata.csv")
    try:
        if os.path.exists(output_csv) and os.path.getsize(output_csv) > 0:
            existing_df = pd.read_csv(output_csv, sep=",", dtype=str)
            # 'Filename' ì»¬ëŸ¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•˜ê³ , ì—†ìœ¼ë©´ ë¹ˆ DataFrame ìƒì„±
            if "Filename" not in existing_df.columns:
                existing_df = pd.DataFrame()
        else:
            existing_df = pd.DataFrame()
    except (pd.errors.EmptyDataError, pd.errors.ParserError):
        existing_df = pd.DataFrame()
    
    for file in os.listdir(input_folder):
        if file.endswith(".pdf"):
            # ê¸°ì¡´ ë°ì´í„°ì—ì„œ ì¤‘ë³µ ì œê±° (Filename ì»¬ëŸ¼ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ)
            if not existing_df.empty and "Filename" in existing_df.columns:
                existing_df = existing_df[existing_df["Filename"] != file]
            process_pdf(os.path.join(input_folder, file), metadata_list, output_folder)
    
    new_df = pd.DataFrame(metadata_list)
    final_df = pd.concat([existing_df, new_df], ignore_index=True) if not existing_df.empty else new_df
    final_df.to_csv(output_csv, index=False, encoding="utf-8-sig", sep=",")
    print(f"ğŸ“„ ë©”íƒ€ë°ì´í„° CSV ì €ì¥ ì™„ë£Œ: {output_csv}")
    return output_csv

def show_main_window():
    root = tk.Tk()
    root.title("PDF ë©”íƒ€ë°ì´í„° ì²˜ë¦¬ ë„êµ¬")
    root.geometry("700x400")
    
    def select_input_folder():
        folder = filedialog.askdirectory(title="ì…ë ¥ í´ë” ì„ íƒ")
        if folder:
            input_folder_var.set(folder)
    
    def select_output_folder():
        folder = filedialog.askdirectory(title="ì¶œë ¥ í´ë” ì„ íƒ")
        if folder:
            output_folder_var.set(folder)
    
    def process_files():
        input_folder = input_folder_var.get()
        output_folder = output_folder_var.get()
        
        if not input_folder or not output_folder:
            messagebox.showerror("ì˜¤ë¥˜", "ì…ë ¥ ë° ì¶œë ¥ í´ë”ë¥¼ ëª¨ë‘ ì„ íƒí•˜ì„¸ìš”.")
            return
        
        log_text.delete(1.0, tk.END)  # ë¡œê·¸ ì´ˆê¸°í™”
        process_pdf_folder(input_folder, output_folder)
    
    input_folder_var = tk.StringVar()
    output_folder_var = tk.StringVar()
    
    frame = tk.Frame(root)
    frame.pack(pady=10)
    
    tk.Label(frame, text="ì…ë ¥ í´ë”:").grid(row=0, column=0, padx=5)
    tk.Entry(frame, textvariable=input_folder_var, width=50).grid(row=0, column=1, padx=5)
    tk.Button(frame, text="ì„ íƒ", command=select_input_folder).grid(row=0, column=2, padx=5)
    
    tk.Label(frame, text="ì¶œë ¥ í´ë”:").grid(row=1, column=0, padx=5)
    tk.Entry(frame, textvariable=output_folder_var, width=50).grid(row=1, column=1, padx=5)
    tk.Button(frame, text="ì„ íƒ", command=select_output_folder).grid(row=1, column=2, padx=5)
    
    # PDF ì²˜ë¦¬ ì‹œì‘ ë²„íŠ¼ì„ ìš°ì¸¡ì— ë°°ì¹˜
    process_button = tk.Button(frame, text="PDF ì²˜ë¦¬ ì‹œì‘", command=process_files, 
                              height=2, width=15, bg="#f0f0f0")
    process_button.grid(row=0, column=3, rowspan=2, padx=20, pady=5)
    
    # ì„¤ëª… í…ìŠ¤íŠ¸ ì˜ì—­ ì¶”ê°€
    description_frame1 = tk.Frame(root)
    description_frame1.pack(fill=tk.X, padx=10, pady=(5, 0))
    
    description_label1 = tk.Label(description_frame1, text="ğŸ“Œ í”„ë¡œê·¸ë¨ ê¸°ëŠ¥ ì„¤ëª…:", anchor="w", font=("Arial", 9, "bold"))
    description_label1.pack(side=tk.LEFT, anchor="nw")
    
    description_frame2 = tk.Frame(root)
    description_frame2.pack(fill=tk.X, padx=10, pady=(0, 5))
    
    description_label2 = tk.Label(description_frame2, text="ì…ë ¥í´ë” ë‚´ PDF íŒŒì¼(í˜•íƒœ: ë‚ ì§œ(20250316)_ë³´ê³ ì„œ.pdf)ì˜ ë©”íƒ€ë°ì´í„°(ìš”ì•½, í‚¤ì›Œë“œ, ë‚ ì§œ)ë¥¼ ìƒì„±í•˜ì—¬ ì¶œë ¥í´ë”ì— ì €ì¥", anchor="w", font=("Arial", 9))
    description_label2.pack(side=tk.LEFT, anchor="nw")
    
    # ë¡œê·¸ í…ìŠ¤íŠ¸ ìœ„ì ¯ ì„¤ì •
    log_text = tk.Text(root, height=10, wrap=tk.WORD)
    log_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
    
    # ì‘ì„±ì ì •ë³´ ì¶”ê°€
    author_label = tk.Label(root, text="Â© 2025 ë„ì‹œí˜ì‹ ê· í˜•ì‹¤ AI í™œì„±í™” ì—°êµ¬íŒ€", fg="gray")
    author_label.pack(side=tk.BOTTOM, pady=5)
    
    # í‘œì¤€ ì¶œë ¥ì„ ë¡œê·¸ í…ìŠ¤íŠ¸ ìœ„ì ¯ìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰ì…˜
    sys.stdout = RedirectText(log_text)
    
    root.mainloop()
    
    # í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œ í‘œì¤€ ì¶œë ¥ ë³µì›
    sys.stdout = sys.__stdout__

if __name__ == "__main__":
    show_main_window()
